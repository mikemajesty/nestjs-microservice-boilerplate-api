# ConvertMongoFilterToBaseRepository Decorator

Transforms **generic filter objects into MongoDB-ready queries** with automatic **nested object flattening**, **ID field mapping**, and **soft delete protection** for low-level MongoDB repository operations.

## The Problem: Generic vs MongoDB Filter Format

### ‚ùå **Without ConvertMongoFilterToBaseRepository - Manual Format Hell**

```typescript
// UGLY: Manual MongoDB filter preparation for base repository methods
export class MongoRepository<T> {
  
  async find<TFil = FilterQuery<T>>(filter: TFil): Promise<T[]> {
    // ‚ùå Manual filter conversion for every method
    let mongoFilter = filter as any
    
    // ‚ùå Manual soft delete addition
    if (!mongoFilter.deletedAt) {
      mongoFilter.deletedAt = null
    }
    
    // ‚ùå Manual ID field mapping
    if (mongoFilter.id) {
      mongoFilter._id = mongoFilter.id
      delete mongoFilter.id
    }
    
    // ‚ùå Manual nested object flattening
    if (mongoFilter.user && typeof mongoFilter.user === 'object') {
      const flatUser = this.flattenObject(mongoFilter.user, 'user')
      delete mongoFilter.user
      mongoFilter = { ...mongoFilter, ...flatUser }\n    }\n    \n    // ‚ùå Manual nested property handling\n    if (mongoFilter.metadata && typeof mongoFilter.metadata === 'object') {\n      const flatMetadata = this.flattenObject(mongoFilter.metadata, 'metadata')\n      delete mongoFilter.metadata\n      mongoFilter = { ...mongoFilter, ...flatMetadata }\n    }\n    \n    try {\n      const results = await this.model.find(mongoFilter)\n      return results.map((d) => this.toObject(d))\n    } catch (error) {\n      throw handleDatabaseError(error, 'find')\n    }\n  }\n  \n  async findOne<TFil = FilterQuery<T>>(filter: TFil): Promise<T | null> {\n    // ‚ùå Copy-paste the same conversion logic again...\n    let mongoFilter = filter as any\n    \n    if (!mongoFilter.deletedAt) {\n      mongoFilter.deletedAt = null\n    }\n    \n    if (mongoFilter.id) {\n      mongoFilter._id = mongoFilter.id\n      delete mongoFilter.id\n    }\n    \n    // ... repeat 20+ lines of the same logic\n  }\n  \n  async updateOne<TQuery = FilterQuery<T>>(filter: TQuery, updated: any): Promise<any> {\n    // ‚ùå Copy-paste the same conversion logic again...\n    // ... another 20+ lines of boilerplate\n  }\n  \n  async remove<TQuery = FilterQuery<T>>(filter: TQuery): Promise<any> {\n    // ‚ùå Copy-paste the same conversion logic again...\n    // ... another 20+ lines of boilerplate\n  }\n  \n  // ‚ùå Manual flattening utility\n  private flattenObject(obj: any, prefix: string): Record<string, any> {\n    const flattened: Record<string, any> = {}\n    \n    for (const key in obj) {\n      const value = obj[key]\n      const fullKey = `${prefix}.${key}`\n      \n      if (value && typeof value === 'object' && !Array.isArray(value)) {\n        const nested = this.flattenObject(value, fullKey)\n        Object.assign(flattened, nested)\n      } else {\n        flattened[fullKey] = value\n      }\n    }\n    \n    return flattened\n  }\n}\n```\n\n### üî• **Problems with Manual Approach:**\n\n1. **Code Duplication** - Same filter conversion logic repeated in every method\n2. **Nested Object Hell** - Manual flattening for MongoDB dot notation\n3. **ID Field Confusion** - Manual `id` ‚Üí `_id` mapping every time\n4. **Soft Delete Forgetting** - Easy to forget `deletedAt: null`\n5. **Type Safety Loss** - Manual casting breaks TypeScript safety\n6. **Maintenance Nightmare** - Change logic? Update 15+ methods\n7. **Error Prone** - Easy to miss conversions or add them inconsistently\n\n## ‚úÖ **The Elegant Solution: ConvertMongoFilterToBaseRepository**\n\n```typescript\nimport { ConvertMongoFilterToBaseRepository } from '@/utils/decorators/database'\n\nexport class MongoRepository<T> {\n  \n  // ‚úÖ BEAUTIFUL: Automatic filter conversion for all MongoDB operations!\n  @ConvertMongoFilterToBaseRepository()\n  async find<TFil = FilterQuery<T>>(filter: TFil): Promise<T[]> {\n    // ‚úÖ Filter automatically converted to MongoDB format!\n    try {\n      const results = await this.model.find(filter as FilterQuery<T>)\n      return results.map((d) => this.toObject(d))\n    } catch (error) {\n      throw handleDatabaseError(error, 'find')\n    }\n  }\n\n  @ConvertMongoFilterToBaseRepository()\n  async findOne<TFil = FilterQuery<T>>(filter: TFil): Promise<T | null> {\n    // ‚úÖ Zero boilerplate - just business logic!\n    try {\n      const data = await this.model.findOne(filter as FilterQuery<T>)\n      return data ? this.toObject(data) : null\n    } catch (error) {\n      throw handleDatabaseError(error, 'findOne')\n    }\n  }\n\n  @ConvertMongoFilterToBaseRepository()\n  async updateOne<TQuery = FilterQuery<T>>(filter: TQuery, updated: any): Promise<any> {\n    // ‚úÖ Filter automatically ready for MongoDB!\n    try {\n      return await this.model.updateOne(\n        filter as FilterQuery<T>,\n        { $set: Object.assign({}, updated) }\n      )\n    } catch (error) {\n      throw handleDatabaseError(error, 'updateOne')\n    }\n  }\n\n  @ConvertMongoFilterToBaseRepository()\n  async remove<TQuery = FilterQuery<T>>(filter: TQuery): Promise<RemovedModel> {\n    // ‚úÖ Automatic soft delete + filter conversion!\n    try {\n      const { deletedCount } = await this.model.deleteOne(filter as FilterQuery<T>)\n      return { deletedCount: deletedCount || 0, deleted: !!deletedCount }\n    } catch (error) {\n      throw handleDatabaseError(error, 'remove')\n    }\n  }\n}\n```\n\n## Automatic Transformations\n\n### **üÜî ID Field Mapping**\n\n```typescript\n// Input filter object\nconst filter = {\n  id: '507f1f77bcf86cd799439011',\n  name: 'John',\n  status: 'active'\n}\n\n// ‚úÖ After ConvertMongoFilterToBaseRepository transformation\nconst mongoFilter = {\n  _id: '507f1f77bcf86cd799439011',  // ‚úÖ id ‚Üí _id automatically\n  name: 'John',\n  status: 'active',\n  deletedAt: null                   // ‚úÖ Soft delete automatically added\n}\n\n// Ready for MongoDB operations!\n```\n\n### **üìä Nested Object Flattening**\n\n```typescript\n// Input with nested objects\nconst complexFilter = {\n  name: 'John',\n  user: {\n    profile: {\n      age: 30,\n      settings: {\n        theme: 'dark',\n        notifications: true\n      }\n    },\n    status: 'active'\n  },\n  metadata: {\n    source: 'web',\n    campaign: 'summer2024'\n  }\n}\n\n// ‚úÖ After automatic flattening\nconst flattenedFilter = {\n  name: 'John',\n  'user.profile.age': 30,                        // ‚úÖ Deep nesting flattened\n  'user.profile.settings.theme': 'dark',         // ‚úÖ MongoDB dot notation\n  'user.profile.settings.notifications': true,   // ‚úÖ Automatic conversion\n  'user.status': 'active',\n  'metadata.source': 'web',                      // ‚úÖ Object flattening\n  'metadata.campaign': 'summer2024',\n  deletedAt: null                                 // ‚úÖ Soft delete protection\n}\n\n// Perfect for MongoDB queries!\n```\n\n### **üõ°Ô∏è Automatic Soft Delete Protection**\n\n```typescript\n// Every method automatically gets soft delete protection\n\n// Input: { status: 'active' }\n// Output: { status: 'active', deletedAt: null }\n\n// Input: { name: 'John', deletedAt: null }\n// Output: { name: 'John', deletedAt: null }  // No duplication\n\n// Input: {} \n// Output: { deletedAt: null }  // Always protected\n```\n\n## Real-World Repository Method Examples\n\n### **üîç Find Operations**\n\n```typescript\nexport class UserRepository extends MongoRepository<UserDocument> {\n  \n  // ‚úÖ All these methods get automatic filter conversion\n  \n  async findActiveUsers(): Promise<UserEntity[]> {\n    // Will be converted to: { status: 'active', deletedAt: null }\n    return this.find({ status: 'active' })\n  }\n  \n  async findByProfile(profileData: ProfileFilter): Promise<UserEntity[]> {\n    // Complex nested filter automatically flattened\n    const filter = {\n      user: {\n        profile: {\n          age: profileData.age,\n          location: profileData.location,\n          preferences: {\n            theme: profileData.theme,\n            language: profileData.language\n          }\n        }\n      }\n    }\n    \n    // ‚úÖ Becomes: {\n    //   'user.profile.age': 30,\n    //   'user.profile.location': 'NYC', \n    //   'user.profile.preferences.theme': 'dark',\n    //   'user.profile.preferences.language': 'en',\n    //   deletedAt: null\n    // }\n    return this.find(filter)\n  }\n}\n```\n\n### **‚úèÔ∏è Update Operations**\n\n```typescript\nexport class OrderRepository extends MongoRepository<OrderDocument> {\n  \n  async updateOrderStatus(orderId: string, status: string): Promise<UpdatedModel> {\n    // ‚úÖ ID automatically mapped, soft delete protected\n    return this.updateOne(\n      { id: orderId },                    // ‚Üí { _id: orderId, deletedAt: null }\n      { status, updatedAt: new Date() }\n    )\n  }\n  \n  async updateNestedOrderData(filter: OrderFilter, data: OrderUpdate): Promise<UpdatedModel> {\n    // ‚úÖ Nested filter automatically flattened\n    const complexFilter = {\n      customer: {\n        profile: {\n          type: filter.customerType,\n          tier: filter.customerTier\n        }\n      },\n      order: {\n        status: filter.orderStatus,\n        payment: {\n          method: filter.paymentMethod\n        }\n      }\n    }\n    \n    // ‚úÖ Becomes MongoDB dot notation automatically\n    return this.updateOne(complexFilter, data)\n  }\n}\n```\n\n### **üóëÔ∏è Delete Operations**\n\n```typescript\nexport class ProductRepository extends MongoRepository<ProductDocument> {\n  \n  async removeProduct(productId: string): Promise<RemovedModel> {\n    // ‚úÖ ID mapped + soft delete check automatically\n    return this.remove({ id: productId })  // ‚Üí { _id: productId, deletedAt: null }\n  }\n  \n  async removeByCategory(categoryData: CategoryFilter): Promise<RemovedModel> {\n    // ‚úÖ Complex nested filter + soft delete protection\n    const filter = {\n      category: {\n        main: categoryData.mainCategory,\n        sub: categoryData.subCategory,\n        metadata: {\n          deprecated: true,\n          migrationDate: { $lt: new Date() }\n        }\n      }\n    }\n    \n    // ‚úÖ Automatically becomes:\n    // {\n    //   'category.main': 'electronics',\n    //   'category.sub': 'phones', \n    //   'category.metadata.deprecated': true,\n    //   'category.metadata.migrationDate': { $lt: Date },\n    //   deletedAt: null\n    // }\n    return this.remove(filter)\n  }\n}\n```\n\n## Advanced Flattening Examples\n\n### **üìä Deep Nested Object Handling**\n\n```typescript\n// Complex nested filter\nconst complexFilter = {\n  id: '507f1f77bcf86cd799439011',\n  analytics: {\n    user: {\n      behavior: {\n        clicks: {\n          total: { $gt: 100 },\n          daily: {\n            average: { $gte: 5 },\n            peak: { $lte: 50 }\n          }\n        },\n        sessions: {\n          duration: { $between: [300, 3600] },\n          pages: {\n            visited: { $in: ['/home', '/products', '/checkout'] }\n          }\n        }\n      }\n    }\n  }\n}\n\n// ‚úÖ After ConvertMongoFilterToBaseRepository\nconst flattenedQuery = {\n  _id: '507f1f77bcf86cd799439011',\n  'analytics.user.behavior.clicks.total': { $gt: 100 },\n  'analytics.user.behavior.clicks.daily.average': { $gte: 5 },\n  'analytics.user.behavior.clicks.daily.peak': { $lte: 50 },\n  'analytics.user.behavior.sessions.duration': { $between: [300, 3600] },\n  'analytics.user.behavior.sessions.pages.visited': { $in: ['/home', '/products', '/checkout'] },\n  deletedAt: null\n}\n```\n\n### **üîÑ Mixed Data Types Handling**\n\n```typescript\n// Filter with mixed types and arrays\nconst mixedFilter = {\n  id: '507f1f77bcf86cd799439011',\n  tags: ['electronics', 'mobile'],           // Array preserved\n  pricing: {\n    amount: 999.99,                          // Number preserved\n    currency: 'USD',                         // String preserved\n    discount: {\n      active: true,                          // Boolean preserved\n      percentage: 15,                        // Number preserved\n      validUntil: new Date('2024-12-31')     // Date preserved\n    }\n  },\n  inventory: {\n    warehouse: {\n      location: 'NYC',\n      stock: { $gte: 10 },                   // MongoDB operator preserved\n      reserved: { $lte: 5 }\n    }\n  }\n}\n\n// ‚úÖ After flattening (types preserved)\nconst result = {\n  _id: '507f1f77bcf86cd799439011',\n  tags: ['electronics', 'mobile'],                    // ‚úÖ Array unchanged\n  'pricing.amount': 999.99,                           // ‚úÖ Number preserved\n  'pricing.currency': 'USD',                          // ‚úÖ String preserved\n  'pricing.discount.active': true,                    // ‚úÖ Boolean preserved\n  'pricing.discount.percentage': 15,                  // ‚úÖ Number preserved  \n  'pricing.discount.validUntil': new Date('2024-12-31'), // ‚úÖ Date preserved\n  'inventory.warehouse.location': 'NYC',              // ‚úÖ String preserved\n  'inventory.warehouse.stock': { $gte: 10 },          // ‚úÖ MongoDB operator preserved\n  'inventory.warehouse.reserved': { $lte: 5 },        // ‚úÖ MongoDB operator preserved\n  deletedAt: null\n}\n```\n\n## MongoDB Performance Benefits\n\n### **üìà Index-Friendly Queries**\n\n```javascript\n// ‚úÖ Flattened queries work perfectly with MongoDB compound indexes\n\n// Index: { \"user.profile.age\": 1, \"user.profile.location\": 1, \"deletedAt\": 1 }\n// Query after flattening:\ndb.users.find({\n  \"user.profile.age\": 30,\n  \"user.profile.location\": \"NYC\", \n  \"deletedAt\": null\n})\n// ‚úÖ Uses compound index efficiently\n```\n\n### **üéØ Precise Field Targeting**\n\n```javascript\n// ‚úÖ Dot notation enables precise field updates\n\n// Instead of updating entire nested object:\ndb.users.updateOne(\n  { _id: ObjectId(\"...\") },\n  { $set: { user: { profile: { age: 31 } } } }  // ‚ùå Overwrites other profile fields\n)\n\n// Flattened approach updates specific field:\ndb.users.updateOne(\n  { _id: ObjectId(\"...\"), deletedAt: null },\n  { $set: { \"user.profile.age\": 31 } }  // ‚úÖ Only updates age field\n)\n```\n\n## Integration with Other Decorators\n\n### **ü§ù Perfect Companion to Other MongoDB Decorators**\n\n```typescript\nexport class CatRepository extends MongoRepository<CatDocument> {\n  \n  // High-level paginate method with complex validation\n  @ConvertMongooseFilter<CatEntity>([\n    { name: 'name', type: SearchTypeEnum.like },\n    { name: 'breed', type: SearchTypeEnum.equal }\n  ])\n  @ValidateDatabaseSortAllowed<CatEntity>({ name: 'createdAt' }, { name: 'breed' })\n  async paginate(input: CatListInput): Promise<CatListOutput> {\n    // ‚úÖ High-level filtering with validation\n    return this.entity.paginate(input.search, { sort: input.sort })\n  }\n  \n  // Low-level base repository methods automatically enhanced\n  async findByOwner(ownerId: string): Promise<CatEntity[]> {\n    // ‚úÖ Automatic filter conversion by ConvertMongoFilterToBaseRepository\n    return this.find({ \n      id: ownerId,           // ‚Üí _id\n      owner: {\n        profile: {\n          verified: true     // ‚Üí owner.profile.verified\n        }\n      }\n    })  // + deletedAt: null automatically\n  }\n}\n```\n\n### **üèóÔ∏è Repository Layer Architecture**\n\n```typescript\n// Base Repository (Infrastructure Layer)\nexport class MongoRepository<T> {\n  // ‚úÖ All base methods decorated with ConvertMongoFilterToBaseRepository\n  @ConvertMongoFilterToBaseRepository()\n  async find(filter: any): Promise<T[]> { /* ... */ }\n  \n  @ConvertMongoFilterToBaseRepository()\n  async findOne(filter: any): Promise<T | null> { /* ... */ }\n  \n  @ConvertMongoFilterToBaseRepository() \n  async updateOne(filter: any, update: any): Promise<any> { /* ... */ }\n}\n\n// Domain Repository (Domain Layer)\nexport class CatRepository extends MongoRepository<CatDocument> {\n  // ‚úÖ High-level methods with business validation\n  @ConvertMongooseFilter<CatEntity>([...])\n  @ValidateDatabaseSortAllowed<CatEntity>([...])\n  async paginate(input: CatListInput): Promise<CatListOutput> {\n    // Business logic + validation\n  }\n  \n  // ‚úÖ Simple methods inherit base repository enhancements\n  async findByBreed(breed: string): Promise<CatEntity[]> {\n    return this.find({ breed })  // Gets ConvertMongoFilterToBaseRepository benefits\n  }\n}\n```\n\n## Why ConvertMongoFilterToBaseRepository is Essential\n\n### **üéØ Infrastructure Layer Enhancement**\n- **Automatic filter normalization** for all base repository methods\n- **Consistent behavior** across all MongoDB operations\n- **Zero configuration** - works transparently\n- **Type preservation** during flattening process\n\n### **üõ°Ô∏è Data Safety**\n- **Soft delete protection** on every query automatically\n- **ID field normalization** prevents MongoDB errors\n- **Consistent filter format** across repository methods\n- **Null safety** for undefined filters\n\n### **‚ö° Performance & Compatibility**\n- **Index-optimized** dot notation queries\n- **MongoDB operator preservation** (\\$gt, \\$in, etc.)\n- **Efficient nested field targeting**\n- **Compound index friendly** query structure\n\n### **üîß Developer Experience**\n- **Zero boilerplate** for filter conversion\n- **Transparent operation** - works behind the scenes\n- **Consistent API** across all repository methods\n- **Type safety** maintained throughout conversion\n\n**ConvertMongoFilterToBaseRepository transforms low-level MongoDB repository operations into a consistent, safe, and optimized data access layer that automatically handles filter formatting, soft deletes, and nested object flattening!** üöÄ